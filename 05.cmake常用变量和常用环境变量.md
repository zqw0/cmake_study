# 1.cmake变量引用的方式:  
前面我们已经提到了，使用${}进行变量的引用。在IF等语句中，是直接使用变量名而不是通过${}取值。
# 2.cmake自定义变量的方式：  
主要有隐式定义和显式定义两张，前面举了一个隐式定义的例子，就是PROJECT指令，他会隐式的定义<projectname>_BINARY_DIR和<projectname>_SOURICE_DIR两个变量。  
  显式定义的例子我们前面也提到了，使用SET指令，就可以构建一个自定义变量了。比如：SET(SRC_LIST hello.cc)。  
  # 3.cmake常用变量  
  &emsp;&#9728;CMAKE_BINARY_DIR,PROJECT_BINARY_DIR,<projectname>_BINARY_DIR   
  这三个变量指代的内容是一致的，如果是in source编译，指的就是工程顶层目录，如果是out-of-source编译，指的就是工程编译发生的目录。PROJECT_BINARY_DIR跟其他指令稍有区别，现在，你可以理解为他们是一致的。  
  &emsp;&#9728;CMAKE_SOURCE_DIR,PROJECT_SOURCE_DIR,<projectname>_SOURCE_DIR  
  这三个变量指代的内容是一致的，不论采用何种编译方式，都是工程顶层目录。也就是在in source编译时，他跟CMAKE_BINARY_DIR等变量一致。PROJECT_SOURCE_DIR跟其他指令稍有区别，现在你可以理解为他们是一致的。  
  &emsp;&#9728;CMAKE_CURRENT_SOURCE_DIR  
  指的是当前处理CMakeLists.txt所在的路径，比如上面我们提到的src子目录。  
  &emsp;&#9728;CMAKE_CURRENT_BINARY_DIR  
  如果是in-source编译，它跟CMAKE_CURRENT_SOURCE_DIR一致，如果是out-of-source编译，他指的是target编译目录。  
  使用我们上面提到的add_subdirectory(src bin)可以更改这个变量的值  
  使用SET(EXECUTABLE_OUTPUT_PATH <新路径>)并不会对这个变量造成影响，它仅仅修改了最终目标文件存放的路径。  
  &emsp;&#9728;CMAKE_CURRENT_LIST_FILE  
  输出调用这个变量的CMakeLists.txt的完整路径。  
  &emsp;&#9728;CMAKE_CURRENT_LIST_LINE  
  输出这个变量所在的行  
  &emsp;&#9728;CMAKE_MODULE_PATH  
  这个变量用来定义自己的cmake模块所在的路径。如果你的工程比较复杂，有可能会自己编写一些cmake模块，这些cmake模块是随你的工程发布的，为了让cmake在处理CMakeLists.txt时找到这些模块，你需要通过SET指令，将自己的cmake模块路径设置一下。比如：
  ```
  SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)
  ```
  这时候你就可以通过INCLUDE指令来调用自己的模块了。  
  &emsp;&#9728;EXECUTABLE_OUTPUT_PATH和LIBRARY_OUTPUT_PATH  
  分别用来重新定义最终结果的存放目录，前面已经提到过了。  
  &emsp;&#9728;PROJECT_NAME  
  返回通过PROJECT指令定义的项目名称。
  # 4.cmake调用环境变量的方式  
  使用$ENV{NAME}指令就可以调用系统的环境变量了。
  比如：
 ```
  MESSAGE(STATUS "HOME dir: $ENV{HOME}")
  ```
  设置环境变量的方式是：
  ```
  SET(ENV{变量名} 值)
  ```
  &emsp;&#9728;CMAKE_INCLUDE_CURRENT_DIR  
  自动添加CMAKE_CURRENT_BINARY_DIR和CMAKE_CURRENT_SOURCE_DIR到当前处理的CMakeLists.txt。相当于在每个CMakeLists.txt加入：
  ```
  INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR})
  ```
&emsp;&#9728;CMAKE_INCLUDE_DIRECTORIES_PROJECT_BEFORE  
  将工程提供的头文件目录始终至于系统头文件目录的前面，当你定义的头文件确实跟系统发
生冲突时可以提供一些帮助。  
  &emsp;&#9728;CMAKE_INCLUDE_PATH和CMAKE_LIBRARY_PATH我们在上一节已经提及。  
  # 5.系统信息  
  &emsp;&#9728;CMAKE_MAJOR_VERSION，CMAKE主版本号，比如2.4.6中的2  
  &emsp;&#9728;2,CMAKE_MINOR_VERSION，CMAKE次版本号，比如2.4.6中的4  
  &emsp;&#9728;3,CMAKE_PATCH_VERSION，CMAKE补丁等级，比如2.4.6 中的6  
   &emsp;&#9728;CMAKE_SYSTEM，系统名称，比如Linux-2.6.22  
  &emsp;&#9728;CMAKE_SYSTEM_NAME，不包含版本的系统名，比如Linux  
  &emsp;&#9728;CMAKE_SYSTEM_VERSION，系统版本，比如2.6.22  
  &emsp;&#9728;CMAKE_SYSTEM_PROCESSOR，处理器名称，比如i686.  
  &emsp;&#9728;UNIX，在所有的类UNIX平台为TRUE，包括OS X和cygwin  
  &emsp;&#9728;WIN32，在所有的win32平台为TRUE，包括cygwin  
  # 6.主要的开关选项：  
  &emsp;&#9728;CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS,用来控制IF ELSE语句的书写下一节语法会讲到。  
  &emsp;&#9728;BUILD_SHARED_LIBS  
  这个开关用来控制默认的库的编译方式，如果不进行设置，使用ADD_LIBRARY并没有制定库类型的情况下，默认编译生成的库都是静态库。  
  如果SET(BUILD_SHARED_LIBS ON)后，默认生成的为动态库。  
  &emsp;&#9728;CMAKE_C_FLAGS  
  设置c编译选项。  
  &emsp;&#9728; CMAKE_CXX_FLAGS  
  设置c++编译选项。
